name: Update Modrinth Project Description

# Updates the Modrinth project description from the repository README.md
# Triggers manually or on push to main (you can adjust branches as needed)
on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'If true, print the payload and do not send to Modrinth'
        required: false
        default: 'false'
  push:
    branches:
      - main

jobs:
  update_description:
    name: Update Modrinth description
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      MODRINTH_API_TOKEN: ${{ secrets.MODRINTH_API_TOKEN }}
      MODRINTH_PROJECT_ID: ${{ secrets.MODRINTH_PROJECT_ID }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Ensure required tools
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Validate README exists
        run: |
          if [ ! -f README.md ]; then
            echo "README.md not found in repository root. Exiting."
            exit 1
          fi

      - name: Build JSON payload from README
        id: build
        run: |
          set -euo pipefail
          # Read README.md into a JSON string safely using jq
          README_CONTENT=$(jq -Rs '.' README.md)
          # Create object with description field
          DATA_JSON=$(jq -n --argdesc "$(jq -Rs '.' README.md)" '{ description: ($argdesc|fromjson) }' --argjson argdesc "$(jq -Rs '.' README.md)") || true
          # Fallback safe method if above is problematic
          if [ -z "$DATA_JSON" ] || [ "$DATA_JSON" = "null" ]; then
            DESC_RAW="$(cat README.md)"
            DATA_JSON=$(jq -n --arg d "$DESC_RAW" '{ description: $d }')
          fi
          echo "$DATA_JSON" > /tmp/modrinth_payload.json
          echo "payload_path=/tmp/modrinth_payload.json" >> $GITHUB_OUTPUT

      - name: Update Modrinth project description
        id: update
        run: |
          set -euo pipefail

          PROJECT_ID="${MODRINTH_PROJECT_ID}"
          TOKEN="${MODRINTH_API_TOKEN}"
          # read dry_run input (defaults to 'false' when not present)
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"
          # normalize token prefix
          if [[ "$TOKEN" != mrp_* ]]; then
            TOKEN="mrp_${TOKEN}"
          fi

          # If the user passed a full Modrinth project URL as the project id (e.g. https://modrinth.com/project/<slug>),
          # extract the final path segment as the slug.
          if [[ "$PROJECT_ID" == *"modrinth.com"* ]]; then
            # strip trailing slash and take last path segment
            PROJECT_ID="$(printf '%s' "$PROJECT_ID" | sed -E 's|/$||' | awk -F/ '{print $NF}')"
            echo "Normalized MODRINTH_PROJECT_ID to '$PROJECT_ID' from provided URL"
          fi

          # Validate required secrets/inputs early to give clear errors
          if [ -z "${PROJECT_ID:-}" ]; then
            echo "ERROR: MODRINTH_PROJECT_ID is not set or is empty."
            echo "Please add the repository secret 'MODRINTH_PROJECT_ID' containing your project's id or slug (e.g. 'AABBCCDD' or 'my-project-slug')."
            exit 1
          fi

          if [ -z "${MODRINTH_API_TOKEN:-}" ]; then
            echo "ERROR: MODRINTH_API_TOKEN is not set or is empty."
            echo "Please add the repository secret 'MODRINTH_API_TOKEN' with a personal access token that has project write permissions."
            exit 1
          fi

          if [ "${DRY_RUN:-false}" = "true" ]; then
            echo "Dry run enabled â€” will not send PATCH to Modrinth."
            echo "Payload (first 4000 chars):"
            head -c 4000 "$PAYLOAD_PATH" || true
            echo
            echo "If you want to actually update the project description, re-run the workflow with dry_run: false or set the input accordingly."
            exit 0
          fi

          PAYLOAD_PATH="${{ steps.build.outputs.payload_path }}"
          if [ ! -f "$PAYLOAD_PATH" ]; then
            echo "Payload not found: $PAYLOAD_PATH"
            exit 1
          fi

          echo "Attempting to update Modrinth project ${PROJECT_ID} description..."
          # Candidate endpoints to try (tries common variants until one works)
          CANDIDATES=(
            "https://api.modrinth.com/v2/project/${PROJECT_ID}"
            "https://api.modrinth.com/project/${PROJECT_ID}"
            "https://staging-api.modrinth.com/project/${PROJECT_ID}"
            "https://staging-api.modrinth.com/v2/project/${PROJECT_ID}"
          )

          LAST_ERR=""
          SUCCESS=0
          for API_URL in "${CANDIDATES[@]}"; do
            echo "Trying $API_URL"
            HTTP_RESPONSE=$(mktemp)
            HTTP_CODE=$(curl -sS -w "%{http_code}" -o "$HTTP_RESPONSE" -X PATCH \
              -H "Authorization: ${TOKEN}" \
              -H "Content-Type: application/json" \
              -H "User-Agent: github_actions/${GITHUB_REPOSITORY}" \
              --data-binary "@$PAYLOAD_PATH" \
              "$API_URL" || true)

            BODY_CONTENT=$(cat "$HTTP_RESPONSE" || true)
            rm -f "$HTTP_RESPONSE"

            echo "HTTP $HTTP_CODE from $API_URL"
            if [ "$HTTP_CODE" = "204" ] || [ "$HTTP_CODE" = "200" ]; then
              echo "Modrinth project updated (HTTP $HTTP_CODE) via $API_URL."
              echo "updated_response={\"status\":$HTTP_CODE, \"endpoint\": \"$API_URL\"}" >> $GITHUB_OUTPUT
              SUCCESS=1
              break
            fi

            # record last body for diagnostics
            LAST_ERR="$API_URL - HTTP $HTTP_CODE - $BODY_CONTENT"
            # If it's a 404 specifically, continue to next candidate; otherwise break and show error
            if [ "$HTTP_CODE" = "404" ]; then
              echo "Route not found at $API_URL, trying next candidate..."
              continue
            else
              echo "Non-success response from $API_URL: HTTP $HTTP_CODE"
              if [ -n "$BODY_CONTENT" ]; then
                if echo "$BODY_CONTENT" | jq -e 'has("error")' >/dev/null 2>&1; then
                  echo "Modrinth API returned an error:" >&2
                  echo "$BODY_CONTENT" | jq -r '.description // .error // tostring' >&2 || true
                else
                  echo "Response body: $BODY_CONTENT" >&2
                fi
              fi
              exit 1
            fi
          done

          if [ "$SUCCESS" -ne 1 ]; then
            echo "All candidate endpoints failed. Last error: $LAST_ERR" >&2
            exit 1
          fi

      - name: Success
        if: success()
        run: |
          echo "Modrinth project description updated successfully."
